# 区域平台开发历程阶段性回顾

不知不觉间，boss 3.0 的开发已经走过了 6 个月的开发时长，经历了 6 个迭代版本。从起初的匆忙起步、中期的加急赶工，到现在的缓慢步入稳定的后期开发，项目开发进入了良性循环，而我们的前端项目组逐渐的成熟起来了。尽管一切都逐渐好了起来。但是，由于前期前端项目小组的技术不成熟，以及缺少资深开发员工的指导，前端项目存在着诸多问题。这些问题有大有小，但是不可忽视。想要前端项目更加“健壮”，我们必须对这些问题加以处理优化。

如何优化？需要先找出问题。接下来，我将根据时间轴逐一列举这 6 个月发生的主要时间：

2 月：项目立项、前端基本框架定型

时间回溯到今年的 2 月份。我们接到通知，要根据现有的 boss 2.0 项目，重新另起一个项目 boss 3.0 。同时，前端小组的另一个资深前端开发人员也提出了离职申请。自然而然的，boss 3.0 的前端决策和引导工作全都落在我身上了。开发人员减少，工作增加，再加上全部事情都需要我来判断决策。顿时压力倍增呀！为了保证开发进度，我不得不采取了比较保守的决策思路。

主要做了以下工作：

- 在技术选型上，考虑到了前端开发人员的技术“亲近度”，我完全沿用了 boss 2.0。这样子，前端开发人员可以快速上手。
- 在项目架构方面，由于没有资深前端开发的指导，而且考虑到 boss 2.0 的代码迁移。我也是基于 boss 2.0，做了优化后就直接使用了。（随着项目的增大，项目架构的不合理部分逐渐暴露）
- 部分相同功能，直接从 boss 2.0 迁移过来做兼容处理。（这是一个比较错误的决定。）

3 月：业务模块“热加载”

经过 2 月的折腾后，项目的开发逐渐稳定了下来。同时，一个新的业务需求出现了——项目代码需要能够对业务模块进行“热加载”。即，业务模块可以自由的加载卸载。这是一个我从未实现过的功能需求，和 boss 2.0 也是完全不一样的。要实现这个功能，我只能从零开始，自己摸索。好在之前的捣鼓过 node 的“自动化”。我很快就想到了这方面。但当我想直接套用 node 那一套时，发现这在前端是实现不通，因为前端是不支持 `path`的。“天无绝人之路”。经过一番查找，终于找到了 webpack 的`require.context` 方法。借助`require.context`，可以实现动态加载 module。这为自动化加载打下了基础。光有“基础”可不行，还需要“顶梁柱”。支撑起这一构思的是 Vue 自身的特性——router。Vue 所有页面的连接都是通过 router 串联起来的。如果某一页面没有被 router 连接或者，某一`component` 没有被 router 连接页面引用。那在 build 时，将被自动排除。所以，要实现热加载，就需要让业务模块的代码高度集合在一起，然后通过 route 暴露出来。通过 route 的的动态加载实现热加载。 route 的动态加载，需要借助 `require.context` 来实现。

尽管，实现了业务模块的“热加载”，由于后期业务模块的划分不精确，导致这部分出现了一些问题。

3 月、4 月：单点登录开发

三四月份是比较忙碌的一段时间。需求的增多，以及前面积累的 bug，让我们不得不延长一个迭代周期来“消化”这些问题。此外，由于单点登录无法实现前后端分离，我不得不到后端代码中编写这部分的页面。这是比较艰难的部分。因为单点登录的代码需要在后台环境下运行，我无法进行调试。而且，一些常用的第三方插件无法使用、或者一些组件需要两头开发（vue，sso）。

5 月、6 月：UI 调整，全局样式调整

这段时间，UI 逐步开始统一设计风格。针对 element-ui 的组件样式，进行了重新设计。这些改动牵动了全局页面，经常导致，这里改动了，但是影响了其他页面的。全局组件的开发最好要在项目启动之初就确定，并实现。如果项目过半变动全局样式，建议专人负责，全局评估查找变动的影响范围。

此外，我们还引入了 extends 组件的开发；对 api 回传参数处理的调整；权限管理。

## 暴露的问题

首先是第一点，项目起初迁移了部分 boss 2.0 的代码，原本想着是能复用。然而在之后的开发中发现，复用代码极其稀少。反而，因为这些代码限制了自己的发挥；其二，业务模块代码的划分不够灵活清晰。尽管在需求上的业务划分是明确的，但是在代码上的划分出现了混乱的情况。这主要体现在，部分模块存在共用代码。如果完全依照需求所描述的业务来划分，就会造成重复开发的情况。其三，中期 UI 调整导致工作量的剧增。在项目进行过半后，UI 才迟迟确定设计风格，产出公用组件设计样式等。这导致了我们前端开发不得不重新审核调整之前开发好的代码。这是一种巨大的内耗，费时费力。而且，可能因为疏忽得原因导致 BUG 的产生。其四，项目架构设计不完善不合理。由于开发经验的不足，项目架构对于大型项目的“支持度”非常低，随着项目愈发庞大，逐渐出现目录架构混乱的情况了。

解决方式

关于 boss 2.0 代码的问题，随着开发的进行，已经基本完成代码的兼容和复用了。接下来，就是要清理无用的代码即可。

二、业务模块的划分问题

重新审视所有的业务模块，对那些存在复用代码的模块，提取复用部分。以公用组件、`slot`、`extends`、`mixins `等形式实现复用。

三、UI 调整

UI 调整这是不可避免的。但是我们可以在尽量避免这种事情的发生。这需要 UI 的配合。在项目立项之初，前端就要配合 UI 尽量将全局样式，通用组件、通用资源等优先设计开发出来。具体如下：

- 设计风格。尽管前端基本都会基于第三方 UI 组件库来开发，但是 UI 很有可能并不希望直接采用原生的设计样式。所有，在项目之初，就需要请 UI 基于 element-ui 设计出一套样式。这是比较重要的。它会给 UI 设计和前端开发定下基调。开发的中期在重新调整全局样式是极其“吃力不讨好”的事情。
- 通用功能组件。对于某些通用功能组件，可以优先设计开发出来。例如 alert 组件、conform 组件等。
- 字体图标。字体图标对性能的提升是很重要的一环。但是，UI 可能并不会主动去产出和维护字体图标。所以在项目立项之初。前端开发可以自己维护或者提醒 UI 产出维护字体图标库。

四、项目架构

项目基础架构对项目的开发以及后期的维护是极其重要的。一个清晰明了的项目架构，有利于快速定位文件，减少查找时间，避免造成混乱。Vue 的项目基本上的都是基于 Vue cli 基础架构生成的。但是，当项目庞大之后，Vue cli 的基础架构就会显得“力不从心”了。如何提升项目架构的“鲁棒性”，又如下几点建议：

1. vuex 模块提取。vuex module 是官方已经支持的功能。vuex 模块的提取有利于更好的维护 vuex，并没 `index.js` 过于臃肿。

2. util 模块提取。当项目庞大后，util 必然也会变得非常庞大。所以，模块化就变得非常重要了。

3. 全局 Filter。将 filter 提取到一个独立的 src 子目录中。此外，也可以进行模块的提取，

4. 全局 mixins。同上。

5. 全局 extends 组件。将 extends 组件从 components 中提取到一个独立的 src 子目录中。

6. axios 模块提取。axios 必然是非常庞大的。如果所有的 api 全都写在一个文件中，查找将是极其痛苦的事情。我们可以按照业务模块来提取子模块。

7. 业务模块代码提取。业务模块的提取又两种方法。一种是在 views 和 components 目录下划分子模块。另一种是在 src 子级新建一个 modules 目录，里面依照业务模块划分项目独立的子模块目录，每个子模块目录相当于子 vue cli。

8. 项目模块导入自动化。如果依照上面的建议进行优化，那你就会发现引入模块的时候是非常痛苦的。当你新增一个子模块时，不但要编写子模块代码，还有去维护子模块的导入代码。特别是在修改模块文件名的时候。项目模块自动导入，正好可以解决这个问题。
